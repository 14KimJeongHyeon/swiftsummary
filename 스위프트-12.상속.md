# [스위프트 대충보기] 11. 상속(inheritence)

- 클래스는 다른 클래스의 메서드, 프로퍼티, 또는 다른 특성을 이어받을(상속, inherit) 수 있다.

- 특성을 전해주는 클래스는 수퍼클래스(superclass), 이어받은 클래스는 서브클래스(subclass)라 한다.

- 서브클래스는 수퍼클래스의 메서드, 프로퍼티, 첨자를 호출하거나, 자신이 이를 재정의(오버라이드, override)할 수 있다. 스위프트는 수퍼 클래스 정의와 오버라이드한 정의가 일치하는지 검사해서 문제가 있으면 지적해 준다.

- 상속한 프로퍼티에 옵저버를 추가할 수 있다. 수퍼클래스이 옵저버 종류(저장 또는 계산)와 관계 없이 서브클래스에서는 옵저버 추가가 가능하다.

## 베이스 클래스 정의하기

- 아무 클래스도 상속하지 않은 클래스는 베이스 클래스(base class)라 한다. 클래스는 `class 이름 { 몸통 }` 순서로 정의한다.

	- 주의: 스위프트는 모든 클래스가 공통으로 상속해야 하는 루트 클래스가 없다. (뻘소리: 아마도 스위프트가 가능한 한 오브젝티브-C에 얇은 레이어를 제공하려는 의도에서 만든 언어라서 이런것 같음. 오브젝티브-C와 스위프트 클래스의 바이너리 레이아웃을 같게 만들려면 이게 최선의 선택이었을 것임.)

- 예제: 운송수단

        class 운송수단 {
            var 바퀴개수: Int
            var 최대승객수: Int
            func 설명() -> String {
                return "\(바퀴개수) 바퀴, 최대 \(최대승객수) 승객 탑승 가능"
            }
            init() {
                바퀴개수 = 0
                최대승객수 = 1
            }
        }

	- init(): 초기화 함수(initializer)

	- 프로퍼티: 바퀴개수, 최대승객수

	- 메서드: 설명()

- 초기화 함수는 메서드와 형태가 비슷하며, 모든 프로퍼티를 초기화해준다.

- 새로 클래스의 인스턴스를 만들려면 클래스 이름 다음에 빈 괄호를 넣어준다.

		let 엉터리운송수단 = 운송수단()

## 서브클래싱(subclassing)

- 서브클래싱: 기존 클래스를 기반으로 새로운 클래스를 만드는 것. 기존 클래스에 새로운 특성을 부여한다.

- 새 클래스에 수퍼클래스가 있음을 알리기 위해 콜론(`:`) 다음에 상속할 수퍼클래스 타입 이름을 적는다.

		class 자전거: 운송수단 {
        	init() {
            	super.init()
                바퀴개수 = 2
            }
        }

	- 예제에서, 초기화 함수를 정의 안에 있는 `super.init()` 수퍼클래스의 `init()`을 호출한다.

	- 주의: 오브젝티브-C와 달리 초기화 함수를 자동으로 상속하지 않는다.

- 서브클래스도 일반 클래스와 마찬가지로 사용할 수 있다.

        let 새자전거 = 자전거()
        println("자전거: \(새자전거.설명())") // 자전거: 2 바퀴, 최대 1 승객 탑승 가능

- 주의: 서브클래스는 수퍼클래스의 var 프로퍼티만 변경 가능하다. 상속받은 상수 프로퍼티는 서브클래스에서 바꿀 수 없다.

## 오버라이딩(overriding)

- 서브클래스에서 수퍼클래스가 정의한 인스턴스 메서드, 클래스 메서드, 인스턴스 프로퍼티, 첨자 등을 다시 정의할 수 있다(다시 정의하지 않으면 당연히 수퍼클래스의 것을 사용한다). 이를 오버라이딩이라 한다.

- 오바라이딩 하려면 정의 앞에 `override` 키워드를 넣으면 된다.

	- `override`를 사용해 의도를 명확히 해야 한다. 만약 `override`를 썼는데 타입이 안 맞으면 컴파일 오류가 나며, `override`가 없는데 수퍼클래스에 이미 있는 메서드를 정의하는 것이라면 역시 컴파일 오류가 난다.

- 수퍼클래스의 메서드, 프로퍼티, 첨자를 액세스하려면 `super.`를 앞에 붙여서 사용한다.

	- super.메서드이름() : 메서드사용
	- super.프로퍼티이름: 프로퍼티 사용
	- super[인덱스] : 첨자 사용

- 메서드 오버라이드하기

        class 자동차: 운송수단 {
            var 속도: Double = 0.0
            init() {
                super.init()
                최대승객수 = 5
                바퀴개수 = 4
            }
            override func 설명() -> String {
                return super.설명() + ", 현재 속도: \(속도) km/h"
            }
        }

- 오버라이드한 메서드 사용

        let 새자동차 = 자동차()
        println("자동차: \(새자동차.설명())")

- 프로퍼티 오버라이드하기: 인스턴스 또는 클래스 프로퍼티의 게터나 세터를 변경하거나, 프로퍼티 옵저버를 추가할 수 있다.

	- 게터와 세터 오버라이드하기: 상속한 프로퍼티는 종류와 관계 없이 모두 오버라이드할 수 있다.

		- 서브클래스는 수퍼클래스의 구현 내용은 모르고 타입과 이름만 안다.

		- 오버라이드를 하려면 타입과 이름을 모두 써야 한다.

		- 수퍼클래스에서 읽기전용이었더라도 서브클래스에서 세터와 게터를 모두 제공할 수는 있지만, 수퍼클래스에서 게터와 세터가 있던 프로퍼티를 서브클라스에서 읽기전용으로 만들 수 없다.

		- 주의: 프로퍼티 오버라이드시 세터를 제공한다면, 반드시 게터도 제공해야 한다. 할일이 없다면 `super.프로퍼티` 라도 넣어라.

                class 속도40제한자동차: 자동차 {
                    override var 속도: Double  {
                        get {
                            return super.속도
                        }
                        set {
                            super.속도 = min(newValue, 40.0)
                        }
                    }
                }


				// 아무리 밟아도 소용없음!
                let 느림보거북이 = 속도40제한자동차()
                느림보거북이.속도 = 60.0
                println("느림보거북이: \(느림보거북이.설명())")

- 프로퍼티 옵저버 오버라이드하기: 상속한 프로퍼티에 옵저버를 정의할 수 있음. 따라서, 상속받은 값이 변할 때 원 구현과 관계 없이 이를 추적할 수 있음.

	- 주의: 상속받은 읽기 전용 프로퍼티나 상수 저장 프로퍼티에는 옵저버를 만들 수 없다. 실제로 이런 값은 변경 자체가 불가능하므로, `willSet`이나 `didSet`이란 것이 의미가 없다.
	- 주의2: 서브클래스에서 세터와 옵저버를 동시에 오버라이드할 수 없다. 세터를 정의하면 세터 안에서 값 변동을 추적할 수 있기 때문이다.

            class 자동변속자동차: 자동차 {
                var 기어 = 1
                override var 속도: Double {
                    didSet {
                        기어 = Int(속도 / 10.0) + 1
                    }
                }
                override func 설명() -> String {
                    return super.설명() + ", 현재 \(기어)단"
                }
            }

            let 새오토차 = 자동변속자동차()
            새오토차.속도 = 35.0
            println("새오토차: \(새오토차.설명())")

## 오버라이드 방지하기

- `@final` 애트리뷰트(attribute)를 정의 앞에 붙이면 오버라이드를 금지할 수 있다.

	- `@final var`

	- `@final func`

	- `@final class func`

	- `@final subscript`

	- `@final`인 대상을 오버라이드하면 컴파일 오류가 발생한다

- 전체 클래스 앞에 `@final`을 붙이면(`@final class ...`) 클래스 전체를 서브클래싱 할 수 없게 막는다.

---
감상: 일반적 OOP와 차이가 없음. 세터와 게터, 옵저버 오버라이딩 부분도 생각해 보면 언어 디자인 시 선택 가능성이 그리 많지는 않음. 