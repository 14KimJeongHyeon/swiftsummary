[스위프트 대충보기] 0. 기본
(물론 한글화 하는 사람들이 있으니 가이드를 한글로 볼 수 있을겁니다. 난 그냥 공부용)

- 상수: let 상수이름 = 값 (굳이 상수라고 이름 붙인걸 보면 기존 코더들을 배려한 것 같음)

- 변수: var 변수이름 = 값

- 여러 선언을 ,로 구분해 한줄에 가능: var x=0.0, y=1, z=10

- 타입지정(타입 애노테이션): 콜론(:) 다음에 타입을 씀. 스위프트난 강타입 언어이지만, 타입 추론을 사용하기 때문에 타입을 직접 쓸 일은 많지 않을 것임

- 이름에는 유니코드 문자 사용 가능. 다만 수학기호, private(또는 잘못된) 유니코드 포인트, 선긋기/박스그리기 문자는 사용할 수 없음. 이름은 숫자로 시작할 수 없음.

- 변수에는 해당 변수 타입에 맞는 값만 대입 가능

- 상수에 대입하면 컴파일 오류

- 콘솔 출력: println

- 한줄 코멘트: // 부터 줄 끝까지

- 여러줄 코멘트: /* 부터 */ 까지. 코멘트 내에 코멘트 내포 가능(당빠 큰 코드블럭 comment out위해 만든 기능)

- 세미콜론: 여러 명령을 한 줄에 쓸 때만 ;로 각 명령을 구분

- 정수: UInt8, Int32 등 크기와 부호 여부에 따라 8, 16, 32, 64비트 정수가 있음

- 정수의 한계값들: UInt8.min, UInt8.max

- Int/UInt : 32비트 머신에서는 Int32/UInt32 64비트 머신에서는 Int64/UInt64 (! 이건 좀 맘에 안드는데 ㅋㅋ)

- 부동소수점수: 3.14159, 0.1, -273.15, 1e18, -1E-9 : Double, Float

- 타입 안전성(type safety) : 스위프트는 타입 안전한 언어. 모든 이름에는 타입이 붙고, 타입 체크를 통과해야 함

- 타입 추론(type inference) : 컴파일러가 각 이름의 사용을 보고 타입을 추론해 부여함. 특별한 경우가 아니면 타입을 직접 표기할 필요가 없음

- 10진 정수 리터럴: 접두사 없는 10진수

- 16진 정수 리터럴: 0x 다음에 16진수

- 8진 정수 리터럴: 0o 다음에 8진수

- 2진 정수 리터럴 : 0b 다음에 2진수

- 10진 부동소수 리터럴: 1.2312e12 = 1.2312 * power(10,12)

- 16진 부동소수 리터럴: 0xF.DCp-2 = 0xF.DC * power(2,-2)

- 가독성을 위해 수 리터럴의 중간에 _를 넣어서 자릿수 표시하거나 앞에 0으로 패딩 가능: 000123.456, 1_000_000

- 기본적으로 크기가 맞지 않은 수를 대입하는 것은 컴파일 오류. let x:UInt8 = -1, var x:Int8 = 257

- 명시적으로 타입 변환: UInt16(1) 등 타입이름(변환대상) 형태의 (팩토리) 메서드 사용

- 정수 -> 부동소수 변환도 물론 명시적으로 해야 함

- 부동소수 -> 정수 변환도 명시적으로 해야 함. 항상 truncate(소숫점 잘라냄-0쪽으로 보내기. 반올림이나 내림이 아님)

- 여러 타입의 수 리터럴간에는 바로 더할 수 있음(0.123+1230 ???)

- 타입 별명(type alias) : typealias AudioSample = UInt16

- 불린(Boolean): 타입 이름은 Bool, 상수는 true/false

- C와 달리 불린 타입을 써야할 자리에 다른 정수 타입을 쓰면 안됨

- 튜플 : (1,2,3)

- 튜플 해체(decompose) : let (status, message) = http404Error

- _를 사용해 관심없는 쪽은 제외할 수 있음 : let (status, _) = http404Error

- .0, .1(0베이스. 1베이스가 아님!)을 사용해 튜플의 원소 액세스 가능: let status = http404Error.0

- 이름붙은 튜플(named tuple)도 있음. let http200Status = (status:200, message:"OK")

- 이름붙은 튜플의 원소는 해당 이름을 사용해 액세스가능: println("status = \(http200Status.status)")

- 튜플 타입은 (Int, String) 처럼 각 원소의 타입을 ,로 분리하고 ()로 둘러쌈. 함수에서 튜플을 반환할 수 있음.

- 옵션(optional) : 어떤 식별자에 값이 있거나 없을 수 있는 경우를 표현. 예: let intValue = possibleNumber.toInt() 하면 수로 변환 가능하면 수가, 아니면 아무것도 아니므로 Int? (Int 옵션형)를 반환

- 값이 있는지 여부는 if로 체크: if intValue { println("\(intValue!)") } else { println("x됐당!")}

- 값을 벗겨내는건 !를 뒤에 붙여서 가져옴. 만약 값이 없는데 !를 사용하면 런타임 오류

- 옵션 바인딩(optional binding) : if let 상수이름 = 옵션값이름 { ... }  : 옵션에 값이 있는 경우에만 "상수이름"에 옵션에 들어있는 값을 넣어줌.

- nil : 옵션 타입의 변수를 값이 없는 상태로 설정하고 싶을 때 사용. var code:Int? = 404; code = nil

- 옵션 타입 변수를 선언하고 값을 초기화하지 않으면 자동으로 nil로 초기화: var code:Int? // code는 nil

- 암시적으로 벗겨낸 옵션(implicitly unwrapped optional): 타입? 대신 타입!로 선언하면 !로 벗겨내지 않고 옵션에 저장한 값을 사용 가능. 물론 이렇게 선언한 변수를 사용하는데, 옵션 내부에 값이 없으면 런타임 오류 발생함. 암.벗.옵을 그냥 옵션이 필요한 자리에 사용하는건 아무 문제 없음

- 단언문(assertion) : assert(age >= 0, "나이는 0보다 작을 수 없음")



